# @generated by Buffham
import dataclasses
import enum
import struct
from typing import Self, Type

from emb.network.serialize import bh_cobs
from emb.network.transport import transporter
from nlb.buffham import bh

from nlb.buffham.testdata import other_bh

# This is a constant in the global scope
MY_CONSTANT = 4
# Constants can be strings as well; they're interpreted with bare words
CONSTANT_STRING = 'Hello, world!'  # constants can have inline comments
# Constants may reference other constants with {brackets}
COMPOSED_CONSTANT = 2 + MY_CONSTANT + other_bh.OTHER_CONSTANT

# Enums can be defined and are treated as uint8_t values
class Verbosity(enum.Enum):
    LOW = 0
    # Comment on MEDIUM
    MEDIUM = 1  # Inline comment on MEDIUM
    HIGH = 2


@dataclasses.dataclass
class Ping:
    """A message comment"""

    # Add some comments here
    ping: int

    def serialize(self) -> bytes:
        buffer = bytes()
        buffer += struct.pack('<B', self.ping)
        return buffer

    @classmethod
    def deserialize(cls, buffer: bytes) -> tuple[Self, int]:
        offset = 0
        ping = struct.unpack_from('<B', buffer, offset)[0]
        offset += 1
        return cls(
            ping=ping,
        ), offset

@dataclasses.dataclass
class FlashPage:
    """
    A bunch of message comments,
    in a block-like pattern.

    All of these belong to `FlashPage`

    """

    address: int
    # Another field comment
    data: list[int]  # What about some in-line comments for fields?
    # This comment belongs to `read_size`
    read_size: int | None  # Fields can be marked optional

    def serialize(self) -> bytes:
        buffer = bytes()
        optional_bitfield = 0
        optional_bitfield |= (1 << 0) if self.read_size is not None else 0
        buffer += optional_bitfield.to_bytes(length=1, byteorder='little', signed=False)
        buffer += struct.pack('<I', self.address)
        buffer += struct.pack('<H', len(self.data))
        buffer += struct.pack(f'<{len(self.data)}B', *self.data)
        buffer += struct.pack('<I', self.read_size) if self.read_size is not None else bytes()
        return buffer

    @classmethod
    def deserialize(cls, buffer: bytes) -> tuple[Self, int]:
        offset = 0
        optional_bitfield = int.from_bytes(buffer[:1], byteorder='little', signed=False)
        offset += 1
        address = struct.unpack_from('<I', buffer, offset)[0]
        offset += 4
        data_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        data = list(struct.unpack_from(f'<{data_size}B', buffer, offset))
        offset += data_size * 1
        read_size = struct.unpack_from('<I', buffer, offset)[0] if optional_bitfield & (1 << 0) else None
        offset += 4 * (read_size is not None)
        return cls(
            address=address,
            data=data,
            read_size=read_size,
        ), offset

@dataclasses.dataclass
class LogMessage:
    message: str
    verbosity: Verbosity
    my_enum: other_bh.MyEnum

    def serialize(self) -> bytes:
        buffer = bytes()
        buffer += struct.pack('<H', len(self.message))
        buffer += self.message.encode()
        buffer += struct.pack('<B', self.verbosity.value)
        buffer += struct.pack('<B', self.my_enum.value)
        return buffer

    @classmethod
    def deserialize(cls, buffer: bytes) -> tuple[Self, int]:
        offset = 0
        message_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        message = buffer[offset:offset + message_size].decode()
        offset += message_size
        verbosity = Verbosity(struct.unpack_from('<B', buffer, offset)[0])
        offset += 1
        my_enum = other_bh.MyEnum(struct.unpack_from('<B', buffer, offset)[0])
        offset += 1
        return cls(
            message=message,
            verbosity=verbosity,
            my_enum=my_enum,
        ), offset

@dataclasses.dataclass
class NestedMessage:
    flag: bool | None
    message: LogMessage
    numbers: list[int]
    pong: Ping
    other_pong: other_bh.Pong

    def serialize(self) -> bytes:
        buffer = bytes()
        optional_bitfield = 0
        optional_bitfield |= (1 << 0) if self.flag is not None else 0
        buffer += optional_bitfield.to_bytes(length=1, byteorder='little', signed=False)
        buffer += struct.pack('<B', self.flag) if self.flag is not None else bytes()
        buffer += self.message.serialize()
        buffer += struct.pack('<H', len(self.numbers))
        buffer += struct.pack(f'<{len(self.numbers)}i', *self.numbers)
        buffer += self.pong.serialize()
        buffer += self.other_pong.serialize()
        return buffer

    @classmethod
    def deserialize(cls, buffer: bytes) -> tuple[Self, int]:
        offset = 0
        optional_bitfield = int.from_bytes(buffer[:1], byteorder='little', signed=False)
        offset += 1
        flag = struct.unpack_from('<B', buffer, offset)[0] if optional_bitfield & (1 << 0) else None
        offset += 1 * (flag is not None)
        message, message_size = LogMessage.deserialize(buffer[offset:])
        offset += message_size
        numbers_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        numbers = list(struct.unpack_from(f'<{numbers_size}i', buffer, offset))
        offset += numbers_size * 4
        pong, pong_size = Ping.deserialize(buffer[offset:])
        offset += pong_size
        other_pong, other_pong_size = other_bh.Pong.deserialize(buffer[offset:])
        offset += other_pong_size
        return cls(
            flag=flag,
            message=message,
            numbers=numbers,
            pong=pong,
            other_pong=other_pong,
        ), offset

@dataclasses.dataclass
class StringLists:
    """Lists can be composed of variable-length strings and bytes"""

    messages: list[str]
    buffers: list[bytes]

    def serialize(self) -> bytes:
        buffer = bytes()
        buffer += struct.pack('<H', len(self.messages))
        for item in self.messages:
            buffer += struct.pack('<H', len(item))
            buffer += item.encode()
        buffer += struct.pack('<H', len(self.buffers))
        for item in self.buffers:
            buffer += struct.pack('<H', len(item))
            buffer += item
        return buffer

    @classmethod
    def deserialize(cls, buffer: bytes) -> tuple[Self, int]:
        offset = 0
        messages_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        messages = []
        for _ in range(messages_size):
            item_size = struct.unpack_from('<H', buffer, offset)[0]
            offset += 2
            messages.append(buffer[offset:offset + item_size].decode())
            offset += item_size
        buffers_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        buffers = []
        for _ in range(buffers_size):
            item_size = struct.unpack_from('<H', buffer, offset)[0]
            offset += 2
            buffers.append(buffer[offset:offset + item_size])
            offset += item_size
        return cls(
            messages=messages,
            buffers=buffers,
        ), offset

REGISTRY: dict[int, Type[bh.BuffhamLike]] = {
    1: LogMessage,
    2: FlashPage,
    3: FlashPage,
    4: LogMessage,
}

class SampleSerializer(bh_cobs.BhCobs):
    def __init__(self, registry: bh_cobs.Registry | None = None):
        registry = (registry or {}) | REGISTRY | other_bh.REGISTRY
        super().__init__(registry)

class SampleNode[
    CommsTransporter: transporter.TransporterLike,
    LogTransporter: transporter.TransporterLike,
](bh.BhNode[SampleSerializer, CommsTransporter, LogTransporter]):
    def __init__(
        self,
        serializer: SampleSerializer | None = None,
        comms_transporter: CommsTransporter | None = None,
        log_transporter: LogTransporter | None = None,
    ):
        super().__init__(serializer or SampleSerializer(), comms_transporter, log_transporter)

PING = bh.Transaction[other_bh.Pong, LogMessage](1)
# Transaction comment
FLASH_PAGE = bh.Transaction[FlashPage, FlashPage](2)
READ_FLASH_PAGE = bh.Transaction[FlashPage, FlashPage](3)  # In-line transaction comment

class PublishIds(enum.Enum):
    # Publish comment
    LOG_MESSAGE = 4  # In-line publish comment
