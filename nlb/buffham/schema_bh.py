# @generated by Buffham
import dataclasses
import enum
import struct
from typing import Self

class FieldType(enum.Enum):
    BOOL = 0
    UINT8_T = 1
    UINT16_T = 2
    UINT32_T = 3
    UINT64_T = 4
    INT8_T = 5
    INT16_T = 6
    INT32_T = 7
    INT64_T = 8
    FLOAT32 = 9
    FLOAT64 = 10
    STRING = 11
    BYTES = 12
    ENUM = 13  # Treated as UINT8_T
    # Some Haskell nerd is going to come along and present a beatiful argument
    # on how terrible my design is, but alas, I do not care.
    LIST = 14
    MESSAGE = 15


@dataclasses.dataclass
class Name:
    name: str
    namespace: str

    def serialize(self) -> bytes:
        buffer = bytes()
        buffer += struct.pack('<H', len(self.name))
        buffer += self.name.encode()
        buffer += struct.pack('<H', len(self.namespace))
        buffer += self.namespace.encode()
        return buffer

    @classmethod
    def deserialize(cls, buffer: bytes) -> tuple[Self, int]:
        offset = 0
        name_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        name = buffer[offset:offset + name_size].decode()
        offset += name_size
        namespace_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        namespace = buffer[offset:offset + namespace_size].decode()
        offset += namespace_size
        return cls(
            name=name,
            namespace=namespace,
        ), offset

@dataclasses.dataclass
class EnumField:
    name: str
    # Assume enums have <=256 values
    value: int
    comments: list[str]
    inline_comment: str | None

    def serialize(self) -> bytes:
        buffer = bytes()
        optional_bitfield = 0
        optional_bitfield |= (1 << 0) if self.inline_comment is not None else 0
        buffer += optional_bitfield.to_bytes(length=1, byteorder='little', signed=False)
        buffer += struct.pack('<H', len(self.name))
        buffer += self.name.encode()
        buffer += struct.pack('<B', self.value)
        buffer += struct.pack('<H', len(self.comments))
        for item in self.comments:
            buffer += struct.pack('<H', len(item))
            buffer += item.encode()
        buffer += struct.pack('<H', len(self.inline_comment)) if self.inline_comment is not None else bytes()
        buffer += self.inline_comment.encode() if self.inline_comment is not None else bytes()
        return buffer

    @classmethod
    def deserialize(cls, buffer: bytes) -> tuple[Self, int]:
        offset = 0
        optional_bitfield = int.from_bytes(buffer[:1], byteorder='little', signed=False)
        offset += 1
        name_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        name = buffer[offset:offset + name_size].decode()
        offset += name_size
        value = struct.unpack_from('<B', buffer, offset)[0]
        offset += 1
        comments_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        comments = []
        for _ in range(comments_size):
            item_size = struct.unpack_from('<H', buffer, offset)[0]
            offset += 2
            comments.append(buffer[offset:offset + item_size].decode())
            offset += item_size
        inline_comment_size = struct.unpack_from('<H', buffer, offset)[0] if optional_bitfield & (1 << 0) else 0
        offset += 2 * (optional_bitfield & (1 << 0))
        inline_comment = buffer[offset:offset + inline_comment_size].decode() if optional_bitfield & (1 << 0) else None
        offset += inline_comment_size
        return cls(
            name=name,
            value=value,
            comments=comments,
            inline_comment=inline_comment,
        ), offset
