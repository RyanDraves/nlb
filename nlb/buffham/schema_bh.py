# @generated by Buffham
import dataclasses
import enum
import struct
from typing import Self

class FieldType(enum.Enum):
    BOOL = 0
    UINT8_T = 1
    UINT16_T = 2
    UINT32_T = 3
    UINT64_T = 4
    INT8_T = 5
    INT16_T = 6
    INT32_T = 7
    INT64_T = 8
    FLOAT32 = 9
    FLOAT64 = 10
    STRING = 11
    BYTES = 12
    ENUM = 13  # Treated as UINT8_T
    # Some Haskell nerd is going to come along and present a beatiful argument
    # on how terrible my design is, but alas, I do not care.
    LIST = 14
    MESSAGE = 15


@dataclasses.dataclass
class Name:
    name: str
    namespace: str

    def serialize(self) -> bytes:
        buffer = bytes()
        buffer += struct.pack('<H', len(self.name))
        buffer += self.name.encode()
        buffer += struct.pack('<H', len(self.namespace))
        buffer += self.namespace.encode()
        return buffer

    @classmethod
    def deserialize(cls, buffer: bytes) -> tuple[Self, int]:
        offset = 0
        name_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        name = buffer[offset:offset + name_size].decode()
        offset += name_size
        namespace_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        namespace = buffer[offset:offset + namespace_size].decode()
        offset += namespace_size
        return cls(
            name=name,
            namespace=namespace,
        ), offset

@dataclasses.dataclass
class Field:
    name: str
    pri_type: FieldType
    # For lists
    sub_type: FieldType | None
    is_optional: bool
    # For messages / enum
    obj_name: Name | None
    comments: list[str]
    inline_comment: str | None

    def serialize(self) -> bytes:
        buffer = bytes()
        optional_bitfield = 0
        optional_bitfield |= (1 << 0) if self.sub_type is not None else 0
        optional_bitfield |= (1 << 1) if self.obj_name is not None else 0
        optional_bitfield |= (1 << 2) if self.inline_comment is not None else 0
        buffer += optional_bitfield.to_bytes(length=1, byteorder='little', signed=False)
        buffer += struct.pack('<H', len(self.name))
        buffer += self.name.encode()
        buffer += struct.pack('<B', self.pri_type.value)
        buffer += struct.pack('<B', self.sub_type.value) if self.sub_type is not None else bytes()
        buffer += struct.pack('<B', self.is_optional)
        buffer += self.obj_name.serialize() if self.obj_name is not None else bytes()
        buffer += struct.pack('<H', len(self.comments))
        for item in self.comments:
            buffer += struct.pack('<H', len(item))
            buffer += item.encode()
        buffer += struct.pack('<H', len(self.inline_comment)) if self.inline_comment is not None else bytes()
        buffer += self.inline_comment.encode() if self.inline_comment is not None else bytes()
        print()
        print(f'Serialize field {self.name=} {self.pri_type=} {self.sub_type=} {self.is_optional=} {self.obj_name=} {self.comments=} {self.inline_comment=} {len(buffer)=}')
        return buffer

    @classmethod
    def deserialize(cls, buffer: bytes) -> tuple[Self, int]:
        offset = 0
        optional_bitfield = int.from_bytes(buffer[:1], byteorder='little', signed=False)
        offset += 1
        name_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        name = buffer[offset:offset + name_size].decode()
        offset += name_size
        print()
        print(f'Deserialize field {optional_bitfield=} {name=} {name_size=} {offset=}')
        pri_type = FieldType(struct.unpack_from('<B', buffer, offset)[0])
        offset += 1
        sub_type = FieldType(struct.unpack_from('<B', buffer, offset)[0]) if optional_bitfield & (1 << 0) else None
        offset += 1 * (sub_type is not None)
        is_optional = struct.unpack_from('<B', buffer, offset)[0]
        offset += 1
        obj_name, obj_name_size = Name.deserialize(buffer[offset:]) if optional_bitfield & (1 << 1) else (None, 0)
        offset += obj_name_size
        comments_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        comments = []
        for _ in range(comments_size):
            item_size = struct.unpack_from('<H', buffer, offset)[0]
            offset += 2
            comments.append(buffer[offset:offset + item_size].decode())
            offset += item_size
        inline_comment_size = struct.unpack_from('<H', buffer, offset)[0] if optional_bitfield & (1 << 2) else 0
        offset += 2 * ((optional_bitfield >> 2) & 1)
        print(2 * ((optional_bitfield >> 2) & 1))
        inline_comment = buffer[offset:offset + inline_comment_size].decode() if optional_bitfield & (1 << 2) else None
        offset += inline_comment_size
        print()
        print(f'Deserialize field {pri_type=} {sub_type=} {is_optional=} {obj_name=} {comments=} {inline_comment=} {offset=}')
        return cls(
            name=name,
            pri_type=pri_type,
            sub_type=sub_type,
            is_optional=is_optional,
            obj_name=obj_name,
            comments=comments,
            inline_comment=inline_comment,
        ), offset

@dataclasses.dataclass
class Message:
    name: str
    fields: list[Field]
    comments: list[str]

    def serialize(self) -> bytes:
        buffer = bytes()
        buffer += struct.pack('<H', len(self.name))
        buffer += self.name.encode()
        buffer += struct.pack('<H', len(self.fields))
        for item in self.fields:
            buffer += item.serialize()
        buffer += struct.pack('<H', len(self.comments))
        for item in self.comments:
            buffer += struct.pack('<H', len(item))
            buffer += item.encode()
        print()
        print(f'Serialize message {self.name=} {self.comments=} {len(buffer)=}')
        return buffer

    @classmethod
    def deserialize(cls, buffer: bytes) -> tuple[Self, int]:
        offset = 0
        name_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        name = buffer[offset:offset + name_size].decode()
        offset += name_size
        fields_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        fields = []
        for _ in range(fields_size):
            item, item_size = Field.deserialize(buffer[offset:])
            fields.append(item)
            offset += item_size
        comments_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        comments = []
        for _ in range(comments_size):
            item_size = struct.unpack_from('<H', buffer, offset)[0]
            offset += 2
            comments.append(buffer[offset:offset + item_size].decode())
            offset += item_size
        print()
        print(f'Deserialize message {name=} {comments=} {offset=}')
        return cls(
            name=name,
            fields=fields,
            comments=comments,
        ), offset

@dataclasses.dataclass
class EnumField:
    name: str
    # Assume enums have <=256 values
    value: int
    comments: list[str]
    inline_comment: str | None

    def serialize(self) -> bytes:
        buffer = bytes()
        optional_bitfield = 0
        optional_bitfield |= (1 << 0) if self.inline_comment is not None else 0
        buffer += optional_bitfield.to_bytes(length=1, byteorder='little', signed=False)
        buffer += struct.pack('<H', len(self.name))
        buffer += self.name.encode()
        buffer += struct.pack('<B', self.value)
        buffer += struct.pack('<H', len(self.comments))
        for item in self.comments:
            buffer += struct.pack('<H', len(item))
            buffer += item.encode()
        buffer += struct.pack('<H', len(self.inline_comment)) if self.inline_comment is not None else bytes()
        buffer += self.inline_comment.encode() if self.inline_comment is not None else bytes()
        return buffer

    @classmethod
    def deserialize(cls, buffer: bytes) -> tuple[Self, int]:
        offset = 0
        optional_bitfield = int.from_bytes(buffer[:1], byteorder='little', signed=False)
        offset += 1
        name_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        name = buffer[offset:offset + name_size].decode()
        offset += name_size
        value = struct.unpack_from('<B', buffer, offset)[0]
        offset += 1
        comments_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        comments = []
        for _ in range(comments_size):
            item_size = struct.unpack_from('<H', buffer, offset)[0]
            offset += 2
            comments.append(buffer[offset:offset + item_size].decode())
            offset += item_size
        inline_comment_size = struct.unpack_from('<H', buffer, offset)[0] if optional_bitfield & (1 << 0) else 0
        offset += 2 * (optional_bitfield & (1 << 0))
        inline_comment = buffer[offset:offset + inline_comment_size].decode() if optional_bitfield & (1 << 0) else None
        offset += inline_comment_size
        return cls(
            name=name,
            value=value,
            comments=comments,
            inline_comment=inline_comment,
        ), offset

@dataclasses.dataclass
class Enum:
    name: str
    fields: list[EnumField]
    comments: list[str]

    def serialize(self) -> bytes:
        buffer = bytes()
        buffer += struct.pack('<H', len(self.name))
        buffer += self.name.encode()
        buffer += struct.pack('<H', len(self.fields))
        for item in self.fields:
            buffer += item.serialize()
        buffer += struct.pack('<H', len(self.comments))
        for item in self.comments:
            buffer += struct.pack('<H', len(item))
            buffer += item.encode()
        return buffer

    @classmethod
    def deserialize(cls, buffer: bytes) -> tuple[Self, int]:
        offset = 0
        name_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        name = buffer[offset:offset + name_size].decode()
        offset += name_size
        fields_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        fields = []
        for _ in range(fields_size):
            item, item_size = EnumField.deserialize(buffer[offset:])
            fields.append(item)
            offset += item_size
        comments_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        comments = []
        for _ in range(comments_size):
            item_size = struct.unpack_from('<H', buffer, offset)[0]
            offset += 2
            comments.append(buffer[offset:offset + item_size].decode())
            offset += item_size
        return cls(
            name=name,
            fields=fields,
            comments=comments,
        ), offset

@dataclasses.dataclass
class Transaction:
    name: str
    # Reasonable size limit on number of transactions/publishes
    request_id: int
    receive_name: Name
    send_name: Name
    comments: list[str]
    inline_comment: str | None

    def serialize(self) -> bytes:
        buffer = bytes()
        optional_bitfield = 0
        optional_bitfield |= (1 << 0) if self.inline_comment is not None else 0
        buffer += optional_bitfield.to_bytes(length=1, byteorder='little', signed=False)
        buffer += struct.pack('<H', len(self.name))
        buffer += self.name.encode()
        buffer += struct.pack('<H', self.request_id)
        buffer += self.receive_name.serialize()
        buffer += self.send_name.serialize()
        buffer += struct.pack('<H', len(self.comments))
        for item in self.comments:
            buffer += struct.pack('<H', len(item))
            buffer += item.encode()
        buffer += struct.pack('<H', len(self.inline_comment)) if self.inline_comment is not None else bytes()
        buffer += self.inline_comment.encode() if self.inline_comment is not None else bytes()
        return buffer

    @classmethod
    def deserialize(cls, buffer: bytes) -> tuple[Self, int]:
        offset = 0
        optional_bitfield = int.from_bytes(buffer[:1], byteorder='little', signed=False)
        offset += 1
        name_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        name = buffer[offset:offset + name_size].decode()
        offset += name_size
        request_id = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        receive_name, receive_name_size = Name.deserialize(buffer[offset:])
        offset += receive_name_size
        send_name, send_name_size = Name.deserialize(buffer[offset:])
        offset += send_name_size
        comments_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        comments = []
        for _ in range(comments_size):
            item_size = struct.unpack_from('<H', buffer, offset)[0]
            offset += 2
            comments.append(buffer[offset:offset + item_size].decode())
            offset += item_size
        inline_comment_size = struct.unpack_from('<H', buffer, offset)[0] if optional_bitfield & (1 << 0) else 0
        offset += 2 * (optional_bitfield & (1 << 0))
        inline_comment = buffer[offset:offset + inline_comment_size].decode() if optional_bitfield & (1 << 0) else None
        offset += inline_comment_size
        return cls(
            name=name,
            request_id=request_id,
            receive_name=receive_name,
            send_name=send_name,
            comments=comments,
            inline_comment=inline_comment,
        ), offset

@dataclasses.dataclass
class Publish:
    name: str
    # Reasonable size limit on number of transactions/publishes
    request_id: int
    send_name: Name
    comments: list[str]
    inline_comment: str | None

    def serialize(self) -> bytes:
        buffer = bytes()
        optional_bitfield = 0
        optional_bitfield |= (1 << 0) if self.inline_comment is not None else 0
        buffer += optional_bitfield.to_bytes(length=1, byteorder='little', signed=False)
        buffer += struct.pack('<H', len(self.name))
        buffer += self.name.encode()
        buffer += struct.pack('<H', self.request_id)
        buffer += self.send_name.serialize()
        buffer += struct.pack('<H', len(self.comments))
        for item in self.comments:
            buffer += struct.pack('<H', len(item))
            buffer += item.encode()
        buffer += struct.pack('<H', len(self.inline_comment)) if self.inline_comment is not None else bytes()
        buffer += self.inline_comment.encode() if self.inline_comment is not None else bytes()
        return buffer

    @classmethod
    def deserialize(cls, buffer: bytes) -> tuple[Self, int]:
        offset = 0
        optional_bitfield = int.from_bytes(buffer[:1], byteorder='little', signed=False)
        offset += 1
        name_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        name = buffer[offset:offset + name_size].decode()
        offset += name_size
        request_id = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        send_name, send_name_size = Name.deserialize(buffer[offset:])
        offset += send_name_size
        comments_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        comments = []
        for _ in range(comments_size):
            item_size = struct.unpack_from('<H', buffer, offset)[0]
            offset += 2
            comments.append(buffer[offset:offset + item_size].decode())
            offset += item_size
        inline_comment_size = struct.unpack_from('<H', buffer, offset)[0] if optional_bitfield & (1 << 0) else 0
        offset += 2 * (optional_bitfield & (1 << 0))
        inline_comment = buffer[offset:offset + inline_comment_size].decode() if optional_bitfield & (1 << 0) else None
        offset += inline_comment_size
        return cls(
            name=name,
            request_id=request_id,
            send_name=send_name,
            comments=comments,
            inline_comment=inline_comment,
        ), offset

@dataclasses.dataclass
class Constant:
    name: str
    type: FieldType
    value: str
    comments: list[str]
    inline_comment: str | None
    references: list[str]

    def serialize(self) -> bytes:
        buffer = bytes()
        optional_bitfield = 0
        optional_bitfield |= (1 << 0) if self.inline_comment is not None else 0
        buffer += optional_bitfield.to_bytes(length=1, byteorder='little', signed=False)
        buffer += struct.pack('<H', len(self.name))
        buffer += self.name.encode()
        buffer += struct.pack('<B', self.type.value)
        buffer += struct.pack('<H', len(self.value))
        buffer += self.value.encode()
        buffer += struct.pack('<H', len(self.comments))
        for item in self.comments:
            buffer += struct.pack('<H', len(item))
            buffer += item.encode()
        buffer += struct.pack('<H', len(self.inline_comment)) if self.inline_comment is not None else bytes()
        buffer += self.inline_comment.encode() if self.inline_comment is not None else bytes()
        buffer += struct.pack('<H', len(self.references))
        for item in self.references:
            buffer += struct.pack('<H', len(item))
            buffer += item.encode()
        return buffer

    @classmethod
    def deserialize(cls, buffer: bytes) -> tuple[Self, int]:
        offset = 0
        optional_bitfield = int.from_bytes(buffer[:1], byteorder='little', signed=False)
        offset += 1
        name_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        name = buffer[offset:offset + name_size].decode()
        offset += name_size
        type = FieldType(struct.unpack_from('<B', buffer, offset)[0])
        offset += 1
        value_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        value = buffer[offset:offset + value_size].decode()
        offset += value_size
        comments_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        comments = []
        for _ in range(comments_size):
            item_size = struct.unpack_from('<H', buffer, offset)[0]
            offset += 2
            comments.append(buffer[offset:offset + item_size].decode())
            offset += item_size
        inline_comment_size = struct.unpack_from('<H', buffer, offset)[0] if optional_bitfield & (1 << 0) else 0
        offset += 2 * (optional_bitfield & (1 << 0))
        inline_comment = buffer[offset:offset + inline_comment_size].decode() if optional_bitfield & (1 << 0) else None
        offset += inline_comment_size
        references_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        references = []
        for _ in range(references_size):
            item_size = struct.unpack_from('<H', buffer, offset)[0]
            offset += 2
            references.append(buffer[offset:offset + item_size].decode())
            offset += item_size
        return cls(
            name=name,
            type=type,
            value=value,
            comments=comments,
            inline_comment=inline_comment,
            references=references,
        ), offset

@dataclasses.dataclass
class Buffham:
    name: Name
    messages: list[Message]
    transactions: list[Transaction]
    publishes: list[Publish]
    constants: list[Constant]
    enums: list[Enum]

    def serialize(self) -> bytes:
        buffer = bytes()
        buffer += self.name.serialize()
        buffer += struct.pack('<H', len(self.messages))
        for item in self.messages:
            buffer += item.serialize()
        buffer += struct.pack('<H', len(self.transactions))
        for item in self.transactions:
            buffer += item.serialize()
        buffer += struct.pack('<H', len(self.publishes))
        for item in self.publishes:
            buffer += item.serialize()
        buffer += struct.pack('<H', len(self.constants))
        for item in self.constants:
            buffer += item.serialize()
        buffer += struct.pack('<H', len(self.enums))
        for item in self.enums:
            buffer += item.serialize()
        return buffer

    @classmethod
    def deserialize(cls, buffer: bytes) -> tuple[Self, int]:
        offset = 0
        name, name_size = Name.deserialize(buffer[offset:])
        offset += name_size
        messages_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        messages = []
        for _ in range(messages_size):
            item, item_size = Message.deserialize(buffer[offset:])
            messages.append(item)
            offset += item_size
        transactions_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        transactions = []
        for _ in range(transactions_size):
            item, item_size = Transaction.deserialize(buffer[offset:])
            transactions.append(item)
            offset += item_size
        publishes_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        publishes = []
        for _ in range(publishes_size):
            item, item_size = Publish.deserialize(buffer[offset:])
            publishes.append(item)
            offset += item_size
        constants_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        constants = []
        for _ in range(constants_size):
            item, item_size = Constant.deserialize(buffer[offset:])
            constants.append(item)
            offset += item_size
        enums_size = struct.unpack_from('<H', buffer, offset)[0]
        offset += 2
        enums = []
        for _ in range(enums_size):
            item, item_size = Enum.deserialize(buffer[offset:])
            enums.append(item)
            offset += item_size
        return cls(
            name=name,
            messages=messages,
            transactions=transactions,
            publishes=publishes,
            constants=constants,
            enums=enums,
        ), offset
