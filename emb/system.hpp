//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           3.0.4
//
//
//       bebopc source:
//           https://github.com/betwixt-labs/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

#pragma once
#include <cstddef>
#include <cstdint>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>
#include "third_party/bebop/bebop.hpp"

struct Config {
  static const size_t minimalEncodedSize = 4;
  uint32_t ping;

  static size_t encodeInto(const Config& message, std::vector<uint8_t>& targetBuffer) {
    ::bebop::Writer writer{targetBuffer};
    return Config::encodeInto(message, writer);
  }

  template<typename T = ::bebop::Writer> static size_t encodeInto(const Config& message, T& writer) {
    size_t before = writer.length();
    writer.writeUint32(message.ping);
    size_t after = writer.length();
    return after - before;
  }

  size_t encodeInto(std::vector<uint8_t>& targetBuffer) { return Config::encodeInto(*this, targetBuffer); }
  size_t encodeInto(::bebop::Writer& writer) { return Config::encodeInto(*this, writer); }

  static Config decode(const uint8_t* sourceBuffer, size_t sourceBufferSize) {
    Config result;
    Config::decodeInto(sourceBuffer, sourceBufferSize, result);
    return result;
  }

  static Config decode(std::vector<uint8_t> sourceBuffer) {
    return Config::decode(sourceBuffer.data(), sourceBuffer.size());
  }

  static Config decode(::bebop::Reader& reader) {
    Config result;
    Config::decodeInto(reader, result);
    return result;
  }

  static size_t decodeInto(const uint8_t* sourceBuffer, size_t sourceBufferSize, Config& target) {
    ::bebop::Reader reader{sourceBuffer, sourceBufferSize};
    return Config::decodeInto(reader, target);
  }

  static size_t decodeInto(std::vector<uint8_t> sourceBuffer, Config& target) {
    return Config::decodeInto(sourceBuffer.data(), sourceBuffer.size(), target);
  }

  static size_t decodeInto(::bebop::Reader& reader, Config& target) {
    target.ping = reader.readUint32();
    return reader.bytesRead();
  }

  size_t byteCount() {
    ::bebop::ByteCounter counter{};
    Config::encodeInto<::bebop::ByteCounter>(*this, counter);
    return counter.length();
  }
};
